<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONT File Manager</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">

    <style>
        .main-container {
            padding: 20px;
            max-width: 100% !important;
            width: 100% !important;
        }
        .content-panel {
            margin-top: 20px;
        }
        .download-button {
            margin: 5px 0;
        }
        #runReportContent {
            width: 100%;
            height: calc(100vh - 100px);
            border: none;
        }
        .ui.tab {
            width: 100%;
        }
        .left-panel {
            width: 20%;
            float: left;
            padding-right: 20px;
            background-color: #f0f0f0; /* Pale gray background */
            padding: 20px;
            height: calc(100vh - 30px); /* Adjust height based on banner height */
        }
        .right-panel {
            width: 75%;
            float: left;
            height: calc(100vh - 30px); /* Adjust height based on banner height */
            overflow-y: auto; /* Make right panel scrollable */
        }
        .banner {
            background-color: rgb(1, 84, 111);
            color: white;
            padding: 15px; /* 1.5x taller */
            text-align: left;
            font-size: 1.5em;
            margin-bottom: 20px;
        }
        .loading-indicator {
            display: none;
            text-align: center;
            padding: 20px;
        }
        #sampleReportContent {
            font-family: Arial, sans-serif;
            font-size: 16px;
            line-height: 1.6;
        }
        .bold-blue {
            font-weight: bold;
            color: rgb(12, 72, 112);
        }
        .bold-green {
            font-weight: bold;
            color: rgb(1, 122, 1);
        }
        .bold-red {
            font-weight: bold;
            color: red;
        }
        .bold-black {
            font-weight: bold;
            color: black;
        }
        .green {
            color: rgb(29, 130, 20);
        }
        .foldable-section {
            margin-bottom: 10px;
        }
        .foldable-header {
            cursor: pointer;
        }
        .foldable-content {
            display: block; /* Make all sections expanded by default */
            margin-left: 10px;
        }

        #ampliconChart {
            width: 100%;
            height: 500px;
        }
        /* Sample report modern header + tabs */
        .sample-header {
            background: linear-gradient(135deg, #0b6b8a 0%, #094b63 100%);
            color: #fff;
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 10px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
        }
        .sample-header .title {
            font-size: 1.4em;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sample-header .meta {
            margin-top: 8px;
            opacity: 0.95;
        }
        .sample-tabs.ui.menu {
            position: sticky;
            top: 0;
            z-index: 2;
            background: #fff;
            border-radius: 8px;
            overflow-x: auto;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .sample-tabs .item {
            flex: 0 0 auto;
            transition: all 0.2s ease;
            border-radius: 6px;
            margin: 2px;
        }
        .sample-tabs .item:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .sample-tabs .item.active {
            background: linear-gradient(135deg, #0b6b8a 0%, #094b63 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(11, 107, 138, 0.3);
        }
        .sample-section.segment {
            border-radius: 8px !important;
            border: 1px solid rgba(34,36,38,.15) !important;
            box-shadow: 0 8px 20px rgba(0,0,0,0.06) !important;
        }
    </style>
</head>
<body>
    <div class="banner">Long-read Sequencing Reports</div>
    <div class="ui container main-container">
        <div class="left-panel">
            <div class="ui form">
                <div class="field">
                    <label>Select a Run:</label>
                    <div class="ui search selection dropdown" id="runSelect">
                        <input type="hidden" name="run">
                        <i class="dropdown icon"></i>
                        <div class="default text">Select Run</div>
                        <div class="menu"></div>
                    </div>
                </div>
                <div class="field">
                    <label>Select a Sample:</label>
                    <div class="ui search selection dropdown" id="sampleSelect">
                        <input type="hidden" name="sample">
                        <i class="dropdown icon"></i>
                        <div class="default text">Select Sample</div>
                        <div class="menu"></div>
                    </div>
                </div>
            </div>
            <div class="ui vertical menu">
                <a class="active item" data-tab="run-report">Run Report</a>
                <a class="item" data-tab="sample-report">Sample Report</a>
                <a class="item" data-tab="downloads">Downloads</a>
            </div>
        </div>
        <div class="right-panel">
            <div class="ui top attached tabular menu" style="display: none;">
                <a class="active item" data-tab="run-report">Run Report</a>
                <a class="item" data-tab="sample-report">Sample Report</a>
                <a class="item" data-tab="downloads">Downloads</a>
            </div>
            
            <div class="ui bottom attached active tab segment" data-tab="run-report">
                <iframe id="runReportContent"></iframe>
                <div class="loading-indicator" id="runReportLoading">Loading...</div>
            </div>
            
            <div class="ui bottom attached tab segment" data-tab="sample-report">
                <div id="sampleReportContent"></div>
            </div>
            
            <div class="ui bottom attached tab segment" data-tab="downloads">
                <div id="downloadContent">
                    <h3>XML File</h3>
                    <div class="ui buttons">
                        <button class="ui button download-button" data-type="xml">Download XML</button>
                    </div>
                    <h3>Log Files</h3>
                    <div class="ui buttons">
                        <button class="ui button download-button" data-type="HapCUT2">Download HapCUT2 log</button>
                        <button class="ui button download-button" data-type="WhatsHap">Download WhatsHap log</button>
                        <button class="ui button download-button" data-type="Pipeline">Download Pipeline log</button>
                    </div>
                </div>
            </div>



            <div class="ui bottom attached tab segment" data-tab="amplicon-data">
                <canvas id="ampliconChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        $(document).ready(function() {
            // Initialize dropdowns and tabs
            $('.ui.dropdown').dropdown();
            $('.menu .item').tab();
    
            // Load runs
            $.get('/api/runs', function(runs) {
                const runMenu = $('#runSelect .menu');
                runs.forEach(run => {
                    runMenu.append(`<div class="item" data-value="${run}">${run}</div>`);
                });
            });
    
            // Run selection handler
            $('#runSelect').dropdown({
                onChange: function(value) {
                    if (!value) return;
    
                    // Show loading indicator
                    $('#runReportLoading').show();
                    $('#runReportContent').hide();
    
                    // Load run HTML into iframe
                    $('#runReportContent').attr('src', `/api/runs/${value}/html`);
    
                    // Hide loading indicator once iframe is loaded
                    $('#runReportContent').on('load', function() {
                        $('#runReportLoading').hide();
                        $('#runReportContent').show();
                    });
    
                    // Reset and load samples
                    $('#sampleSelect').dropdown('clear');
                    $.get(`/api/runs/${value}/samples`, function(samples) {
                        console.log("Received samples:", samples);  // Debug log
                        const sampleMenu = $('#sampleSelect .menu');
                        sampleMenu.empty();
                        samples.forEach(sample => {
                            sampleMenu.append(`<div class="item" data-value="${sample}">${sample}</div>`);
                        });
                        $('#sampleSelect').dropdown('refresh');  // Corrected line
                    });
                }
            });
    
            // Sample selection handler
            $('#sampleSelect').dropdown({
                onChange: function(value) {
                    if (!value) return;
                    const runId = $('#runSelect').dropdown('get value');
    
                    // Load sample report
                    $.get(`/api/runs/${runId}/samples/${value}/report`, function(report) {
                        // Split report into sections by headers that start with '='
                        const lines = report.split('\n');
                        let sections = [];
                        let currentSection = [];
    
                        lines.forEach(line => {
                            line = line.trim();
                            if (line.startsWith('=')) {
                                if (currentSection.length > 0) {
                                    sections.push(currentSection);
                                }
                                currentSection = [line];
                            } else {
                                currentSection.push(line);
                            }
                        });
                        if (currentSection.length > 0) {
                            sections.push(currentSection);
                        }
    
                        // Build header from the first section, and tabs from the remaining sections
                        const buildStyledLines = (linesArr) => linesArr.map(line => {
                                if (line.startsWith('*')) {
                                    return line.includes('PASSED') ? `<span class="bold-green">${line}</span>` : `<span class="bold-red">${line}</span>`;
                                } else if (line.startsWith('Counting') || line.startsWith('WhatsHap') || line.startsWith('HapCUT2')) {
                                    return line.replace(/(Cis|Trans)/g, '<strong>$1</strong>');
                                } else if (line.endsWith('<-')) {
                                    return `<span class="green">${line}</span>`;
                                } else {
                                    return line;
                                }
                        }).join('<br>');

                        const firstSection = sections[0] || [];
                        const firstTitleRaw = firstSection[0] || '';
                        const firstTitle = firstTitleRaw.replace(/=+/g, '').trim();
                        const firstContentHtml = buildStyledLines((firstSection.slice ? firstSection.slice(1) : []));
                        const headerHtml = `
                            <div class="sample-header">
                                <div class="title">${firstTitle || 'Sample Report'}</div>
                            </div>
                        `;

                        // Normalize titles helper
                        const normalizeTitle = (t) => (t || '')
                            .toLowerCase()
                            .replace(/=+/g, '')
                            .replace(/[^a-z0-9]+/g, ' ')
                            .trim();

                        // Build section objects for remaining sections
                        let sectionObjs = sections.slice(1).map((section) => {
                            const header = section[0] || '';
                            const title = header.replace(/=+/g, '').trim();
                            const titleNorm = normalizeTitle(title);
                            const lines = section.slice(1);
                            return { header, title, titleNorm, lines };
                        });

                        // Move specific content from Result to Quality Control
                        const idxResult = sectionObjs.findIndex(s => s.titleNorm === 'result' || s.titleNorm === 'results');
                        const idxQCForMove = sectionObjs.findIndex(s => s.titleNorm === 'quality control');
                        
                        if (idxResult !== -1 && idxQCForMove !== -1) {
                            const resultLines = sectionObjs[idxResult].lines;
                            const qcLines = sectionObjs[idxQCForMove].lines;
                            
                            // Find and move "Detailed categorisation of reads" section (including Trans reads line)
                            const detailedCatStart = resultLines.findIndex(line => line.includes('Detailed categorisation of reads:'));
                            if (detailedCatStart !== -1) {
                                // Find the end of the detailed categorization section
                                let detailedCatEnd = resultLines.findIndex((line, idx) => idx > detailedCatStart && 
                                    (line.includes('Cis reads') || line.includes('Trans reads')));
                                
                                // If we found Cis reads, look for the line after Trans reads
                                if (detailedCatEnd !== -1 && resultLines[detailedCatEnd].includes('Cis reads')) {
                                    detailedCatEnd = resultLines.findIndex((line, idx) => idx > detailedCatEnd && 
                                        line.includes('Trans reads'));
                                    if (detailedCatEnd !== -1) {
                                        detailedCatEnd += 1; // Include the Trans reads line
                                    }
                                } else if (detailedCatEnd !== -1) {
                                    detailedCatEnd += 1; // Include the found line
                                }
                                
                                const endIdx = detailedCatEnd !== -1 ? detailedCatEnd : resultLines.length;
                                const detailedCatLines = resultLines.splice(detailedCatStart, endIdx - detailedCatStart);
                                
                                // Find QC PASSED/FAILED line to insert before
                                const qcStatusIdx = qcLines.findIndex(line => 
                                    line.includes('QC PASSED') || line.includes('QC passed') || 
                                    line.includes('QC FAILED') || line.includes('QC failed'));
                                if (qcStatusIdx !== -1) {
                                    qcLines.splice(qcStatusIdx, 0, ...detailedCatLines);
                                } else {
                                    qcLines.unshift(...detailedCatLines);
                                }
                            }
                            
                            // Find and move "Chimeric reads percentage" line with spacing
                            const chimericIdx = resultLines.findIndex(line => line.includes('Chimeric reads percentage:'));
                            if (chimericIdx !== -1) {
                                const chimericLine = resultLines.splice(chimericIdx, 1)[0];
                                
                                // Find QC PASSED/FAILED line to insert before
                                const qcStatusIdx2 = qcLines.findIndex(line => 
                                    line.includes('QC PASSED') || line.includes('QC passed') || 
                                    line.includes('QC FAILED') || line.includes('QC failed'));
                                if (qcStatusIdx2 !== -1) {
                                    // Add spacing before and after chimeric reads line
                                    qcLines.splice(qcStatusIdx2, 0, '', chimericLine, '');
                                } else {
                                    qcLines.unshift('', chimericLine, '');
                                }
                            }
                        }

                        // Merge Variant Validation into Quality Control and remove Variant Validation panel
                        const idxVV = sectionObjs.findIndex(s => s.titleNorm === 'variant validation');
                        let idxQC = sectionObjs.findIndex(s => s.titleNorm === 'quality control');
                        if (idxVV !== -1) {
                            if (idxQC === -1) {
                                // Create Quality control section if missing
                                sectionObjs.push({
                                    header: 'Quality control',
                                    title: 'Quality control',
                                    titleNorm: 'quality control',
                                    lines: []
                                });
                                idxQC = sectionObjs.length - 1;
                            }
                            // Prepend Variant Validation text to Quality Control
                            sectionObjs[idxQC].lines = sectionObjs[idxVV].lines.concat(sectionObjs[idxQC].lines);
                            // Remove Variant Validation panel
                            sectionObjs.splice(idxVV, 1);
                        }

                        // Desired order: Result -> Quality control -> Variant calling
                        const rankMap = new Map([
                            ['result', 0],
                            ['results', 0],
                            ['quality control', 1],
                            ['variant calling', 2]
                        ]);
                        sectionObjs.sort((a, b) => {
                            const ra = rankMap.has(a.titleNorm) ? rankMap.get(a.titleNorm) : 100;
                            const rb = rankMap.has(b.titleNorm) ? rankMap.get(b.titleNorm) : 100;
                            if (ra !== rb) return ra - rb;
                            return 0; // keep relative order for others
                        });

                        // For non-phasing reports without a Result section, create a Result tab with meta information
                        const isPhasingReport = sectionObjs.some(s => s.lines.some(line => 
                            line.includes('Counting') && line.includes('WhatsHap') && line.includes('HapCUT2')
                        ));
                        
                        if (!isPhasingReport && !sectionObjs.some(s => s.titleNorm === 'result' || s.titleNorm === 'results')) {
                            // Create a Result tab for non-phasing reports
                            const allMetaLines = firstContentHtml.split('<br>').filter(line => 
                                line.trim() !== '' && !line.includes('---')
                            ).join('<br>');
                            
                            // Add this as a new section object at the beginning
                            sectionObjs.unshift({
                                header: 'Result',
                                title: 'Result',
                                titleNorm: 'result',
                                lines: [allMetaLines]
                            });
                            
                            // Re-sort sections to maintain order
                            const rankMap = new Map([
                                ['result', 0],
                                ['results', 0],
                                ['quality control', 1],
                                ['variant calling', 2]
                            ]);
                            sectionObjs.sort((a, b) => {
                                const ra = rankMap.has(a.titleNorm) ? rankMap.get(a.titleNorm) : 100;
                                const rb = rankMap.has(b.titleNorm) ? rankMap.get(b.titleNorm) : 100;
                                if (ra !== rb) return ra - rb;
                                return 0;
                            });
                        }
                        
                        // Move Variant Matching and Variant 1 from Variant Calling to Result tab
                        const idxResultForVariantMove = sectionObjs.findIndex(s => s.titleNorm === 'result' || s.titleNorm === 'results');
                        const idxVariantCalling = sectionObjs.findIndex(s => s.titleNorm === 'variant calling');
                        
                        if (idxResultForVariantMove !== -1 && idxVariantCalling !== -1) {
                            const resultLines = sectionObjs[idxResultForVariantMove].lines;
                            const variantLines = sectionObjs[idxVariantCalling].lines;
                            
                            // Find and copy Variant Matching and Variant 1
                            const variantMatchingIdx = variantLines.findIndex(line => line.includes('Variant Matching:'));
                            if (variantMatchingIdx !== -1) {
                                const variantMatchingLine = variantLines[variantMatchingIdx];
                                const variant1Idx = variantLines.findIndex(line => line.includes('Variant 1:'));
                                const variant1Line = variant1Idx !== -1 ? variantLines[variant1Idx] : '';
                                
                                // Find "Passing QC reads:" line to insert after
                                const passingQCIdx = resultLines.findIndex(line => line.includes('Passing QC reads:'));
                                
                                if (passingQCIdx !== -1) {
                                    // Insert after "Passing QC reads:" with proper spacing
                                    const insertIdx = passingQCIdx + 1;
                                    if (variantMatchingLine || variant1Line) resultLines.splice(insertIdx, 0, ''); // Add spacing before
                                    if (variantMatchingLine) resultLines.splice(insertIdx + 1, 0, variantMatchingLine);
                                    if (variant1Line) resultLines.splice(insertIdx + 2, 0, variant1Line);
                                    if (variantMatchingLine || variant1Line) resultLines.splice(insertIdx + 3, 0, ''); // Add spacing after
                        } else {
                                    // If "Passing QC reads:" not found, add to the end
                                    if (variantMatchingLine || variant1Line) resultLines.push(''); // Add spacing
                                    if (variantMatchingLine) resultLines.push(variantMatchingLine);
                                    if (variant1Line) resultLines.push(variant1Line);
                                }
                            }
                        }
                        

                        
                        // Build tabs
                        const menuItems = [];
                        const segmentsHtml = [];
                        sectionObjs.forEach((s, idx) => {
                            let contentHtml = buildStyledLines(s.lines);
                            
                            // Add meta lines from first section to Result tab
                            if (idx === 0 && (s.titleNorm === 'result' || s.titleNorm === 'results')) {
                                // Check if this is a phasing report (has Counting/WhatsHap/HapCUT2 lines)
                                const isPhasingReport = contentHtml.includes('Counting') && contentHtml.includes('WhatsHap') && contentHtml.includes('HapCUT2');
                                
                                if (isPhasingReport) {
                                    // Filter out dashed lines from meta content for phasing reports
                                    const cleanMetaLines = firstContentHtml.split('<br>').filter(line => 
                                        !line.includes('---') && line.trim() !== ''
                                    ).join('<br>');
                                    
                                    // Process Result section with controlled spacing for phasing reports
                                    let processedContent = contentHtml;
                                    
                                    // Remove ALL extra spacing first - be more aggressive
                                    processedContent = processedContent.replace(/<br><br>/g, '<br>');
                                    processedContent = processedContent.replace(/<br><br>/g, '<br>'); // Do it twice to catch any remaining
                                    
                                    // Add controlled spacing for specific patterns
                                    processedContent = processedContent.replace(/(Amplicon region:.*?)<br>(Amplicon length:)/g, '$1<br><br>$2');
                                    processedContent = processedContent.replace(/(Amplicon length:.*?)<br>(Variant 1:)/g, '$1<br><br>$2');
                                    processedContent = processedContent.replace(/(Variant 1:.*?)<br>(Variant 2:)/g, '$1<br><br>$2');
                                    processedContent = processedContent.replace(/(Variant 2:.*?)<br>(Distance between variants:)/g, '$1<br><br>$2');
                                    processedContent = processedContent.replace(/(Distance between variants:.*?)<br>(Total high quality spanning reads:)/g, '$1<br><br>$2');
                                    processedContent = processedContent.replace(/(Total high quality spanning reads:.*?)<br>(Counting.*?(?:Cis|Trans))/g, '$1<br><br>$2');
                                    
                                    // Group the three phase analysis lines together with NO extra spacing
                                    processedContent = processedContent.replace(/(Counting.*?(?:Cis|Trans))<br>(WhatsHap.*?(?:Cis|Trans))<br>(HapCUT2.*?(?:Cis|Trans))/g, '$1<br>$2<br>$3');
                                    
                                    contentHtml = cleanMetaLines + '<br><br>' + processedContent;
                                } else {
                                    // For non-phasing reports, don't add meta lines if there's already content
                                    // This prevents duplication
                                    if (!contentHtml.trim()) {
                                        const allMetaLines = firstContentHtml.split('<br>').filter(line => 
                                            line.trim() !== '' && !line.includes('---')
                                        ).join('<br>');
                                        contentHtml = allMetaLines;
                                    }
                                }
                            }
                            
                            const tabId = `section-${idx+1}`;
                            menuItems.push(`<a class="item ${idx === 0 ? 'active' : ''}" data-tab="${tabId}">${s.title}</a>`);
                            segmentsHtml.push(`<div class="ui bottom attached tab segment sample-section ${idx === 0 ? 'active' : ''}" data-tab="${tabId}">${contentHtml}</div>`);
                        });

                        const tabsWrapper = menuItems.length
                          ? `<div class="ui pointing secondary menu sample-tabs">${menuItems.join('')}</div>${segmentsHtml.join('')}`
                          : '';

                        // Inject the header + tabs into the sample report container
                        $('#sampleReportContent').html(headerHtml + tabsWrapper);

                        // Initialize tabs for the newly inserted menu
                        $('#sampleReportContent .menu .item').tab();

                        // Automatically switch to the sample report tab
                        $('.menu .item[data-tab="sample-report"]').tab('change tab', 'sample-report');
                    });



                    // Highlight selected sample in scatter plot
                    $.get('/api/amplicon_data', function(data) {
                        const ctx = document.getElementById('ampliconChart').getContext('2d');
                        const chartData = {
                            datasets: [{
                                label: 'Amplicon Data',
                                data: data.map(item => ({
                                    x: item[2], // amplicon_size
                                    y: item[3] > 0 ? item[3] : item[4], // total_high_quality_spanning_reads or passing_qc_reads
                                    r: Math.log10(item[4]), // total_reads in log scale
                                    sample: item[1], // sample_id
                                    backgroundColor: item[1] === value ? 'rgba(0, 0, 139, 0.8)' : 'rgba(54, 162, 235, 0.6)', // dark blue for selected sample
                                    borderColor: item[1] === value ? 'rgba(0, 0, 139, 1)' : 'rgba(54, 162, 235, 1)', // dark blue for selected sample
                                    borderWidth: 1,
                                    radius: item[1] === value ? 10 : 5 // 10% larger for selected sample
                                }))
                            }]
                        };
                        const chartOptions = {
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Amplicon Size'
                                    }
                                },
                                y: {
                                    type: 'logarithmic',
                                    title: {
                                        display: true,
                                        text: 'Total High Quality Spanning Reads'
                                    }
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const data = context.raw;
                                            return `Sample: ${data.sample}, Amplicon Size: ${data.x}, Total High Quality Spanning Reads: ${data.y}, Total Reads: ${Math.pow(10, data.r)}`;
                                        }
                                    }
                                }
                            }
                        };
                        new Chart(ctx, {
                            type: 'bubble',
                            data: chartData,
                            options: chartOptions
                        });
                    });
                }
            });
    
            // Download handler
            $('.download-button').click(function() {
                const runId = $('#runSelect').dropdown('get value');
                const sampleId = $('#sampleSelect').dropdown('get value');
                const fileType = $(this).data('type');
    
                if (runId && sampleId) {
                    window.location.href = `/api/runs/${runId}/samples/${sampleId}/download/${fileType}`;
                } else {
                    alert('Please select both a run and a sample first.');
                }
            });

            // Load Amplicon Data and create scatter chart
            $.get('/api/amplicon_data', function(data) {
                const ctx = document.getElementById('ampliconChart').getContext('2d');
                const chartData = {
                    datasets: [{
                        label: 'Amplicon Data',
                        data: data.map(item => ({
                            x: item[2], // amplicon_size
                            y: item[3] > 0 ? item[3] : item[4], // total_high_quality_spanning_reads or passing_qc_reads
                            r: Math.log10(item[4]), // total_reads in log scale
                            sample: item[1] // sample_id
                        })),
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                };
                const chartOptions = {
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Amplicon Size'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Total High Quality Spanning Reads'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const data = context.raw;
                                    return `Sample: ${data.sample}, Amplicon Size: ${data.x}, Total High Quality Spanning Reads: ${data.y}, Total Reads: ${Math.pow(10, data.r)}`;
                                }
                            }
                        }
                    }
                };
                new Chart(ctx, {
                    type: 'bubble',
                    data: chartData,
                    options: chartOptions
                });
            });
        });
    </script>
</body>
</html>